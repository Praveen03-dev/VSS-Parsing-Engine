/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <android/hardware/automotive/vehicle/2.0/IVehicle.h>
#include <unordered_map>
#include <functional>
#include <string>
#include <memory>

namespace android {
namespace hardware {
namespace automotive {
namespace vehicle {
namespace V2_0 {
namespace impl {

using ::android::hardware::automotive::vehicle::V2_0::VehiclePropValue;
using ::android::hardware::automotive::vehicle::V2_0::VehiclePropertyType;
using ::android::hardware::automotive::vehicle::V2_0::VehicleProperty;

/**
 * Converter function signature for converting VSS values to VHAL format.
 * Takes a raw VSS value string and populates a VehiclePropValue structure.
 */
using VssConverterFunction = std::function<bool(const std::string&, VehiclePropValue&)>;

/**
 * AndroidVssConverter bridges the gap between external VSS data format 
 * and the internal Android VHAL format. It provides dynamic conversion
 * capabilities through a mapping system generated by the Python parsing tool.
 * 
 * The core functionality involves:
 * 1. Maintaining a map of VSS signal paths to conversion functions
 * 2. Converting raw VSS string values to proper VHAL VehiclePropValue objects
 * 3. Handling unit conversions and data type transformations
 * 4. Providing error handling and validation
 */
class AndroidVssConverter {
public:
    AndroidVssConverter();
    ~AndroidVssConverter();

    /**
     * Initialize the converter with generated mapping data.
     * This method populates the conversion map with functions
     * generated by the Python tool.
     * @return true if initialization was successful, false otherwise
     */
    bool initialize();

    /**
     * Convert a VSS signal to VHAL format.
     * @param vssPath VSS signal path (e.g., "Vehicle.Speed")
     * @param vssValue Raw VSS value as string (e.g., "120.5")
     * @param vhalPropValue Output parameter for converted VHAL property
     * @return true if conversion was successful, false otherwise
     */
    bool convertVssToVhal(const std::string& vssPath, 
                          const std::string& vssValue, 
                          VehiclePropValue& vhalPropValue);

    /**
     * Check if a VSS signal path has a conversion mapping.
     * @param vssPath VSS signal path to check
     * @return true if mapping exists, false otherwise
     */
    bool hasMapping(const std::string& vssPath) const;

    /**
     * Get the number of available conversion mappings.
     * @return Number of VSS signals that can be converted
     */
    size_t getMappingCount() const;

    /**
     * Get VHAL property ID for a VSS path (if mapping exists).
     * @param vssPath VSS signal path
     * @return VHAL property ID, or 0 if no mapping exists
     */
    int32_t getVhalPropertyId(const std::string& vssPath) const;

private:
    /**
     * Initialize the conversion mapping with generated functions.
     * This method is populated by the Python template generator.
     */
    void initConversionMap();

    /**
     * Helper function to create and initialize a VehiclePropValue structure.
     * @param propertyId VHAL property ID
     * @param areaId Area ID (typically 0 for global properties)
     * @return Initialized VehiclePropValue structure
     */
    VehiclePropValue createPropValue(int32_t propertyId, int32_t areaId = 0);

    // Generated conversion functions for different data types
    // These will be populated by the template generator
    
    {% for mapping in conversion_mappings -%}
    /**
     * Convert {{ mapping.vss_path }} ({{ mapping.vss_datatype }}) to VHAL format
     * Property ID: {{ mapping.vhal_property_id }}
     * VHAL Type: {{ mapping.vhal_type }}
     */
    bool convert{{ mapping.vss_path|replace('.', '_')|replace('[', '_')|replace(']', '_') }}(
        const std::string& value, VehiclePropValue& propValue);
    
    {% endfor %}

    // Conversion mapping: VSS path -> conversion function
    std::unordered_map<std::string, VssConverterFunction> mConversionMap;
    
    // VSS path to VHAL property ID mapping for quick lookups
    std::unordered_map<std::string, int32_t> mVssToVhalIdMap;
    
    // Initialization state
    bool mInitialized;
};

}  // namespace impl
}  // namespace V2_0
}  // namespace vehicle
}  // namespace automotive
}  // namespace hardware
}  // namespace android
